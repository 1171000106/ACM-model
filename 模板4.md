[TOC]



### 数学

$$
\mu^2(n) = \sum_{d^2|n}\mu(d)
$$

$$
d(ij)=\sum_{p|i}\sum_{q|j}[(p,q)=1]
$$

勾股数公式：a=m^2-n^2,b=2mn,c=m^2+n^2

积性函数求和的题不会做时：考虑质数的贡献，然后乘起来。bzoj3560: DZY Loves Math V

FFT做字符串匹配，必须位置对应，转化的是权值

伯努利数求自然数幂和 O(k)。伯努利数如下。注意特判m=n=0
$$
\sum_{k=1}^n k^m=\frac{1}{m + 1}\sum_{k=0}^{m}{m+1 \choose k} B_{k} (n+1)^{m+1-k}=\frac{1}{m+1}\sum_{k=1}^{m+1}{m+1 \choose k}B_{m+1-k}(n+1)^k \\
\sum_{k=0}^n {n+1 \choose k} B_k=0 \\
B_0=1,B_n=-\frac{1}{n + 1}\sum_{k=0}^{n-1}{n+1 \choose k} B_k
$$
可以做成多项式形式，即
$$
\sum_{k=1}^nk^m=\sum_{k=1}^{m+1}a_kn^k
$$
深度 $\le \frac{n}{k}$ 的树至少有 $k$ 个叶子。

 *Cayley's formula* 的一般化：$n$ 个带标号点形成 $k$ 棵树的方案数为 $T_{n,k}=k*n^{n-k-1}$ 。



威尔逊定理：
$$
(p-1)!=-1 \ (mod \ p),p\ is\ prime
$$
证明：[0,p-1]内每个数都有逆元，逆元为本身的只有1和p-1，剩下的两两相消。

二进制下1的个数,  num = __builtin_popcount(a) 

康托展开：
$$
X=a_n(n-1)!+a_{n-1}(n-2)!+\cdots+a_1\cdot0!
$$
next_permutation：

```c++
    sort(arr,arr+n);    // sort arr[] in ascending order
    do{
        for(int i=0; i<n; printf("%d ",arr[i++])); printf("\n");
    }while(next_permutation(arr,arr+n));
```



#### hash模数

```c++
const static ULL p1 = 1000056479;
const static ULL p2 = 1000189471;
```



#### BSGS

```c++
LL BSGS(LL a,LL b,LL mod) { //a^x = b (% mod)
    a %= mod; b %= mod;
    if(a == 0 && b == 0) return 1;
    else if(a == 0) return -1;
    unordered_map<int,int> h;
    LL m = ceil(sqrt(mod));
    LL amni = ksm(a,mod - m - 1,mod);
    LL t = 1;
    h[t] = 0;
    for(int i = 1;i < m;i ++) {
        t = (t * a) % mod;
        if(t != 1 && !h[t])
            h[t] = i;
    }
    for(int i = 0;i <= m - 1;i ++) {
        LL ans = h[b];
        if(b == 1 || ans)
            return i * m + ans;
        b = (b * amni) % mod;
    }
    return -1;
}
```



#### 扩展中国剩余定理

```c++
LL excrt(LL*r,LL*a,int n){ // x%r=a
    LL M=a[1],R=r[1],x,y,d;
    for(int i=2;i<=n;i++){
        d = exgcd(M,a[i],x,y);
        x = MulMod((R-r[i])/d, x, a[i]);
        R -= M*x;
        M = M/d * a[i];
    }
    return (R%M+M)%M;
}
```



#### 扩展卢卡斯

```c++
struct Exlucas {
    inline void exgcd(LL a,LL b,LL &x,LL &y){
        if(!b) { x=1,y=0; return; }
        exgcd(b,a%b,x,y);
        LL t = x;
        x = y,y = t-(a/b)*y;
    }
    inline LL inv(LL a,LL b){
        LL x,y;
        return exgcd(a,b,x,y),(x%b+b)%b;
    }
    inline LL ksm(LL a,LL b,LL p){
        LL ans = 1;
        while(b){
            if(b&1) ans = a * ans % p;
            a = a * a % p;
            b >>= 1;
        }
        return ans;
    }
    inline LL crt(LL x,LL p,LL mod){
        return inv(p/mod,mod)*(p/mod)*x;
    }
    inline LL fac(LL x,LL a,LL b){
        if(!x) return 1;
        LL ans = 1;
        for(int i=1;i<=b;i++)
            if(i%a)
                ans = ans * i % b;
        ans = ksm(ans,x/b,b);
        for(int i=1;i<=x%b;i++)
            if(i%a)
                ans = ans * i % b;
        return ans * fac(x/a,a,b)%b;
    }
    inline LL C(LL n,LL m,LL a,LL b){
        LL N=fac(n,a,b),M=fac(m,a,b),Z=fac(n-m,a,b),sum=0;
        for(LL i=n;i;i=i/a) sum+=i/a;
        for(LL i=m;i;i=i/a) sum-=i/a;
        for(LL i=n-m;i;i=i/a) sum-=i/a;
        return N*ksm(a,sum,b)%b*inv(M,b)%b*inv(Z,b)%b;
    }
    inline LL exlucas(LL n,LL m,LL p){
        LL t = p,ans = 0;
        for(LL i = 2;i * i <= p;i ++){
            LL k = 1;
            while(t % i == 0) k *= i,t /= i;
            ans+=crt(C(n,m,i,k),p,k),ans%=p;
        }
        if(t>1) ans += crt(C(n,m,t,t),p,t),ans%=p;
        return ans % p;
    }
}exlcs;
```



#### 高斯消元

```c++
bool gauss(double g[][SZ],int n,double ans[]) {
    int now = 1;
    for(int i = 1;i < n;i ++) {
        int to;
        for(to = now;to < n;to ++)
            if(fabs(g[to][i]) > eps) break;
        if(to >= n) continue;
        if(to != now)
            for(int j = 1;j <= n;j ++)
                swap(g[to][j],g[now][j]);
        double t = g[now][i];
        for(int j = 1;j <= n;j ++)
            g[now][j] /= t;
        for(int j = 1;j < n;j ++)
            if(j != now) {
                double num = g[j][i];
                for(int k = 1;k <= n;k ++)
                    g[j][k] -= num * g[now][k];
            }
        now ++; 
    }
    for(int i = 1;i < n;i ++) ans[i] = g[i][n];
    for(int i = now;i < n;i ++) if(fabs(g[i][n]) > eps) return false;
    return true;
}
```

```c++
//求行列式 整数 取模
int gauss(int mat[12][12],int n) {
    int res = 1;
    for(int i = 1; i <= n; i++) {
        for(int j = i; j <= n; j++)
            if(mat[j][i]!=0) {
                for(int k = i; k <= n; k++) swap(mat[i][k],mat[j][k]);
                if(i != j) res = (-res+mod)%mod;
                break;
            }
        if(mat[i][i] == 0) { res = 0; break; }
        for(int j = i+1; j <= n; j++) {
            int mut = (1ll*mat[j][i]*ksm(mat[i][i],mod-2))%mod;
            for(int k = i; k <= n; k++)
                mat[j][k] = (mat[j][k]-(1ll*mat[i][k]*mut)%mod+mod)%mod;
        }
        res = (1ll*res * mat[i][i])%mod;
    }
    return res;
}
```

#### NTT&FFT

```c++
struct Complex {
    double x,y;
    Complex(double x = 0,double y = 0) :x(x),y(y) {}
    Complex operator *(const Complex &o) const { return Complex(x*o.x-y*o.y,x*o.y+y*o.x);}
    void operator /=(const double &o) { x /= o; y /= o;}
    Complex operator +(const Complex &o) const { return Complex(x + o.x,y + o.y);}
    Complex operator -(const Complex &o) const { return Complex(x - o.x,y - o.y);}
};

struct FFT {
    void Transform(Complex a[],int n,const int opt) {
        for(int i = 0,j = 0;i < n;i ++) {
            if(i > j) swap(a[i],a[j]);
            for(int k = n >> 1;(j ^= k) < k;k >>= 1);
        }
        for(int l = 2;l <= n;l <<= 1) {
            int m = l / 2;
            Complex wn = (Complex){cos(2*PI/l),opt*sin(2*PI/l)};
            for(Complex *p = a;p != a + n;p += l) {
                Complex w = (Complex){1,0};
                for(int i = 0;i < m;i ++,w = w * wn) {
                    Complex t = w * p[i + m];
                    p[i + m] = p[i] - t;
                    p[i] = p[i] + t;
                }
            }
        }
    }
    void dft(Complex a[],int n) {
        Transform(a,n,1);
    }

    void idft(Complex a[],int n) {
        Transform(a,n,-1);
        for(int i = 0;i < n;i ++) {
            a[i].x /= n; a[i].y /= n;
        }
    }
}fft;

struct NTTranform {
   	const int g = 3;
	void Transform(int *a,int n,int opt) {
        for(int i = 0,j = 0;i < n;i ++) {
            if(i < j) swap(a[i],a[j]);
            for(int k = n >> 1;(j ^= k) < k;k >>= 1);
        }
        for(int l = 2;l <= n;l *= 2) {
            int m = l / 2;
            int wn = ksm(g,(mod-1)/l);
            if(opt == -1) wn = ksm(wn,mod - 2);
            for(int *p = a;p != a + n;p += l) {
                for(int i = 0,w = 1;i < m;i ++,w=1ll*w*wn%mod) {
                    int t = 1ll * w * p[m + i] % mod;
                    p[m + i] = (p[i] - t + mod) % mod;
					(p[i] += t) %= mod;
                }
            }
        }
	}
	void dft(int *a,const int n) {
        Transform(a,n,1);
	}
	void idft(int *a,const int n) {
        Transform(a,n,-1);
        int t = ksm(n,mod - 2);
        for(int i = 0;i < n;i ++) a[i] = 1ll * a[i] * t % mod;
	}
}ntt;

void multiply(int *a,int n,int *b,int m,int *ans) { /// need 4 times memory
    static int c1[SZ],c2[SZ];
	int len = 1;
    while(len < n + m) len *= 2;
    for(int i = 0;i < len;i ++) c1[i] = c2[i] = 0;
    for(int i = 0;i < n;i ++) c1[i] = a[i];
    for(int i = 0;i < m;i ++) c2[i] = b[i];
    ntt.dft(c1,len); ntt.dft(c2,len);
    for(int i = 0;i < len;i ++) c1[i] = 1ll * c1[i] * c2[i] % mod;
    ntt.idft(c1,len);
    for(int i = 0;i < n + m - 1;i ++) ans[i] = (c1[i] + mod) % mod;
}

void inverse(int *a,int n,int *b) { /// need 4 times memory
    static int A[SZ];
    b[0] = ksm(a[0],mod-2);
    for(int l = 2;l < n*2;l <<= 1) {
        for(int i = 0;i < l;i ++) A[i] = a[i];
        for(int i = l;i < l*2;i ++) A[i] = 0;
        for(int i = l/2;i < l*2;i ++) b[i] = 0;
        ntt.dft(A,l*2); ntt.dft(b,l*2);
        for(int i = 0;i < l*2;i ++) b[i] = (b[i]*2-1ll*A[i]*b[i]%mod*b[i]%mod+mod)%mod;
        ntt.idft(b,l*2);
    }
}

void divide(int *a,int n,int *b,int m,int *D) { /// need 4 times memory
    static int bni[SZ];
    if(n<m) { D[0]=0; return ; }
    reverse(a,a+n); reverse(b,b+m);
    inverse(b,n-m+1,bni);
    multiply(a,n-m+1,bni,n-m+1,D);
    reverse(D,D+n-m+1);
    reverse(a,a+n); reverse(b,b+m);
}

void modular(int *a,int n,int *b,int m,int *R) { /// need 4 times memory
    static int D[SZ],c[SZ];
    if(n<m) { for(int i = 0;i < n;i ++) R[i] = a[i]; return ; }
    divide(a,n,b,m,D);
    multiply(b,m,D,n-m+1,c);
    for(int i = 0;i < m-1;i ++) R[i] = (a[i] - c[i] + mod) % mod;
}

void sqrt(int *a,int n,int *b) { /// a[0]=1  need 8 times memory
    static int c1[SZ],c2[SZ],ni2 = ksm(2,mod-2);
    b[0] = 1;
    for(int l = 2;l < n*2;l <<= 1) {
        inverse(b,l*2,c2);
        multiply(a,l*2,c2,l*2,c1);
        for(int i = 0;i < l*2;i ++) b[i] = 1ll*(b[i]+c1[i])*ni2%mod;
    }
}

void derivative(int *a,int n,int *b) {
    b[n-1] = 0;
    for(int i = 0;i < n-1;i ++) b[i] = 1ll * a[i+1] * (i+1) % mod;
}

void integral(int *a,int n,int *b) {
    for(int i = n;i >= 0;i --) b[i] = a[i-1] * ksm(i,mod-2) % mod;
}

void ln(int *a,int n,int *b) { ///a[0]=1
    static int c1[SZ],c2[SZ],c3[SZ];
    inverse(a,n,c1);
    derivative(a,n,c2);
    multiply(c1,n,c2,n-1,c3);
    integral(c3,n+1,b);
}

void exp(int *a,int n,int *b) { ///a[0]=1
    static int c[SZ];
    b[0] = 1;
    for(int l = 2;l < n*2;l <<= 1) {
        ln(b,l,c);
        for(int i = 0;i < l;i ++) c[i] = (a[i]-c[i]+mod)%mod;
        c[0] ++; multiply(c,l,b,l,b);
    }
}

void sin(int *a,int n,int *b) { ///a[0]=0
    static int A[SZ],B[SZ],C[SZ];
    const int j = 86583718,ni2j = ksm(86583718*2%mod,mod-2);
    for(int i = 0;i < n;i ++) A[i] = 1ll * a[i] * j % mod; exp(A,n,B);
    for(int i = 0;i < n;i ++) A[i] = 1ll * a[i] * (mod-j) % mod; exp(A,n,C);
    for(int i = 0;i < n;i ++) b[i] = 1ll*(B[i]-C[i]+mod)*ni2j%mod;
}

void cos(int *a,int n,int *b) { ///a[0]=0
    static int A[SZ],B[SZ],C[SZ];
    const int j = 86583718,ni2 = ksm(2,mod-2);
    for(int i = 0;i < n;i ++) A[i] = 1ll * a[i] * j % mod; exp(A,n,B);
    for(int i = 0;i < n;i ++) A[i] = 1ll * a[i] * (mod-j) % mod; exp(A,n,C);
    for(int i = 0;i < n;i ++) b[i] = 1ll*(B[i]+C[i])*ni2%mod;
}

void tan(int *a,int n,int *b) {
    static int A[SZ],B[SZ];
    sin(a,n,A); cos(a,n,B);
    inverse(B,n,b); multiply(A,n,b,n,b);
}

void arcsin(int *a,int n,int *b) { ///a[0]=0
    static int c[SZ],A[SZ];
    multiply(a,n,a,n,c);
    derivative(a,n,A);
    for(int i = 0;i < n;i ++) c[i] = (mod-c[i])%mod;
    c[0] ++; sqrt(c,n,b); inverse(b,n,c);
    multiply(c,n,A,n,c); integral(c,n-1,b);
}

void arctan(int *a,int n,int *b) { ///a[0]=0
    static int c[SZ],A[SZ];
    multiply(a,n,a,n,b); derivative(a,n,A); b[0] ++;
    inverse(b,n,c); multiply(c,n,A,n,c); integral(c,n-1,b);
}

void power(int *a,int n,int k,int *b) {
    static int c[SZ],d[SZ];
    LL t = 0;
    for(int i = 0;i < n;i ++) if(a[i]) { t = i; break; }
    for(int i = 0;i < n-t;i ++) c[i] = a[i+t];

    if(t*k>=n)
        for(int i = 0;i < n;i ++) b[i] = 0;
    else {
        int x = c[0];
        for(int i = 0;i < n-t*k;i ++) c[i] = c[i] * ksm(x,mod-2) % mod;
        ln(c,n-t*k,d); /// a[0]=1的话只要这一行到exp，项数改为n即可
        for(int i = 0;i < n-t*k;i ++) d[i] = 1ll * d[i] * k % mod;
        exp(d,n-t*k,b);
        x = ksm(x,k);
        for(int i = n-1;i >= t*k;i --) b[i] = 1ll * b[i-t*k] * x % mod;
        for(int i = 0;i < t*k;i ++) b[i] = 0;
    }
}
```

#### 伯努利数

```c++
inv[1] = 1;B[0] = 1;
for(int i = 2;i <= 3010;i ++) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;
for(int i = 1;i <= 3009;i ++) {
    for(int j = 0;j <= i - 1;j ++)
        (B[i] += 1ll * C[i + 1][j] * B[j] % mod) %= mod;
    B[i] = -1ll * B[i] * inv[i + 1] % mod;
}

namespace pre_mi {
    int a[3100];
    void pre_poly(int m) {
        for(int i = 1;i <= m + 1;i ++) a[i] = 0;
        int x = ksm(m + 1,mod - 2);
        for(int k = 1;k <= m + 1;k ++) a[k] = 1ll * C[m + 1][m + 1 - k] * B[m + 1 - k] % mod * x % mod;
        if(m) a[m] ++;
    }
    LL mi(int n,int m) {
        pre_poly(m);
        LL ans = 0;
        for(int k = 1;k <= m + 1;k ++) {
            (ans += a[k] * ksm(n,k) % mod) %= mod;
        }
        ans += mod; ans %= mod;
        return ans;
    }
}
```

#### FWT

$$
OR:IFWT(A)=(IFWT(A_0),IFWT(A_1)-IFWT(A_0)) \\
AND:IFWT(A)=(IFWT(A_0)-IFWT(A_1),IFWT(A_1)) \\
XOR:IFWT(A)=(\frac{IFWT(A_0)+IFWT(A_1)}{2},\frac{IFWT(A_0)-IFWT(A_1)}{2})
$$

题意：给 n 个数组，每个数组中有 x 个 $a_i$ ，y 个 $b_i$ ，z 个 $c_i$ 。要求每个数组中取出恰好一个数将其异或起来。问得到 i 的方案数是多少。求所有的 i 从 0 到 $2^k-1$ 。 $n \le 10^5 ,k \le 17$

key：FWT

首先一个暴力做法是构造 n 个长度为 $2^k$ 的数组，做 n 遍 fwt，其中每个数组中只有至多三个非零元素： $F_i[a_i]=x,F_i[b_i]=y,F_i[c_i]=z$ 。下面开始复习 fwt。

因为 fwt 是线性变换，即变换后的每个元素是变换前的 $2^k$ 个元素的线性组合。由于本题只有三个非零元素，并且是异或的 fwt ，所以线性组合的系数是 1 或 -1。

fwt 对异或的变换为 $f_i = \sum_j (-1)^{count(i\&j)}a_j$ ，其中 $count(x)$ 为 x 的二进制中 1 的个数。

若变化为 $F_i[0]=A,F_i[b_i\ xor\ a_i]=B,F_i[c_i\ xor\ a_i]=C$ ，则可以发现每个数组经 fwt 后只有四种元素：$A+B+C,A+B-C,A-B+C,A-B-C$ 。最终答案需要异或所有 $a_i$ 作映射。

于是对于第 i 位，若以上四种元素在所有数组的第 i 位中出现次数分别是 $x,y,z,w$ ，则答案为 $(A+B+C)^x*(A+B-C)^y*(A-B+C)^z*(A-B-C)^w$ ，现在的问题是确定 $x,y,z,w$ 。

其实若 $F[0]=A,F[b]=B,F[c]=C,F[c\ xor\ b]=D$ ，则由 fwt 对异或的变换可知变换后的数组只包含 $A+B+C+D,A+B-C-D,A-B+C-D,A-B-C+D$ 这四种元素。 

设 $B=1，A=C=0$ 、 $C=1,A=B=0$ 以及 $F_i[b_i\ xor\ c_i]=1$ 可得三个线性无关方程，以及显然的 $x+y+z+w=n$ 。现在有四个方程，可以解出每一位的 $x,y,z,w$。最后再做一遍 fwt 逆变换即可。

其实这个做法很容易拓展，可以出 m 个非零元素，或者运算不是异或。



```c++
void FWT_or(int *a,int opt)
{
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
                if(opt==1)a[i+j+k]=(a[j+k]+a[i+j+k])%MOD;
                else a[i+j+k]=(a[i+j+k]+MOD-a[j+k])%MOD;
}
void FWT_and(int *a,int opt)
{
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
                if(opt==1)a[j+k]=(a[j+k]+a[i+j+k])%MOD;
                else a[j+k]=(a[j+k]+MOD-a[i+j+k])%MOD;
}
void FWT_xor(int *a,int opt) //[0,n)
{
    for(int i=1;i<N;i<<=1)
        for(int p=i<<1,j=0;j<N;j+=p)
            for(int k=0;k<i;++k)
            {
                int X=a[j+k],Y=a[i+j+k];
                a[j+k]=(X+Y)%MOD;a[i+j+k]=(X+MOD-Y)%MOD;
                if(opt==-1)a[j+k]=1ll*a[j+k]*inv2%MOD,a[i+j+k]=1ll*a[i+j+k]*inv2%MOD;
            }
}
```

#### pollard_rho Miller_Rabin

```c++
namespace MR {
    bool check(LL a,LL n,LL x,LL t) {
        LL ans = ksm(a,x,n),lst = ans;
        for(int i = 1;i <= t;i ++) {
            ans = mul(ans,ans,n);
            if(ans == 1 && lst != 1 && lst != n - 1) return true;
            lst = ans;
        }
        if(ans != 1) return true;
        return false;
    }	
    const int S = 8;
    bool Miller_Rabin(LL n) {
        if(n < 2) return false;
        if(n == 2) return true;
        if((n & 1) == 0) return false;
        LL x = n - 1,t = 0;
        while((x & 1) == 0) x >>= 1,t ++;
        for(int i = 0;i < S;i ++) {
            LL a = rand() % (n - 1) + 1;
            if(check(a,n,x,t)) return false;
        }
        return true;
    }
}

namespace Pr {
    LL Pollard_rho(LL x,LL c) {
        LL i = 1,k = 2,x0 = rand() % (x - 1) + 1,y = x0;
        while(1) {
            i ++;
            x0 = (mul(x0,x0,x) + c) % x;
            LL d = gcd(abs(y-x0),x);
            if(d != 1 && d != x) return d;
            if(y == x0) return x;
            if(i == k) y = x0,k <<= 1;
        }
    }
    
    void findfac(LL n,LL factor[]) {
        if(n == 1) return ;
        if(MR :: Miller_Rabin(n)) {
            factor[++ factor[0]] = n;
            return ;
        }
        LL p = n;
        while(p >= n) p = Pollard_rho(n,rand() % (n - 1) + 1);
        findfac(p,factor); findfac(n/p,factor); 
    }
}
```

#### 求原根

```c++
int getG(int p) {
    if(p == 2) return 1;
    vector<int> getGtmp;
    int x = p - 1;
    for(int i = 2;i <= x;i ++) if(x % i == 0) getGtmp.push_back(i);
    for(int k = 2;;k ++)
        for(int i = 0;i < getGtmp.size();i ++) {
            if(ksm(k,getGtmp[i],p) == 1) {
                if(getGtmp[i] == x)
                    return k;
                else break;
            }
        }
}
```

#### 快速乘

```c++
inline LL mul(LL x,LL y,LL z) {
    return (x*y-(LL)(((long double)x*y+0.5)/(long double)z)*z+z)%z;
}
inline LL multi(LL x,LL y,LL mod) {
	LL tmp=(x*y-(LL)((long double)x/mod*y+1.0e-8)*mod);
	return tmp<0 ? tmp+mod : tmp;
}
```

#### 快速取模

```c++
#include <cstdio>
#include <cassert>
#include <ctime>
#include <iostream>

using i64 = long long;
using u64 = unsigned long long;
using u128 = __uint128_t;

struct Mod64
{
    Mod64() : n_(0) {}
    Mod64(u64 n) : n_(init(n)) {}
    static u64 modulus() { return mod; }
    static u64 init(u64 w) { return reduce(u128(w) * r2); }
    static void set_mod(u64 m)
    {
        mod = m;
        assert(mod & 1);
        inv = m;
        for (int i = 0; i < 5; ++i)
            inv *= 2 - inv * m;
        r2 = -u128(m) % m;
    }
    static u64 reduce(u128 x)
    {
        u64 y = u64(x >> 64) - u64((u128(u64(x) * inv) * mod) >> 64);
        return i64(y) < 0 ? y + mod : y;
    }
    Mod64 &operator+=(Mod64 rhs)
    {
        n_ += rhs.n_ - mod;
        if (i64(n_) < 0)
            n_ += mod;
        return *this;
    }
    Mod64 operator+(Mod64 rhs) const { return Mod64(*this) += rhs; }
    Mod64 &operator*=(Mod64 rhs)
    {
        n_ = reduce(u128(n_) * rhs.n_);
        return *this;
    }
    Mod64 operator*(Mod64 rhs) const { return Mod64(*this) *= rhs; }
    u64 get() const { return reduce(n_); }
    static u64 mod, inv, r2;
    u64 n_;
};
u64 Mod64::mod, Mod64::inv, Mod64::r2;

inline u64 mod128_64_small(u128 a, u64 b)
{
    u64 q, r;
    __asm__(
        "divq\t%4"
        : "=a"(q), "=d"(r)
        : "0"(u64(a)), "1"(u64(a >> 64)), "rm"(b));
    return r;
}

u64 fact_mod_fast(int N, u64 mod)
{
    Mod64::set_mod(mod);
    Mod64 ret = Mod64(1), one = ret, t = one;
    for (int i = 1; i <= N; ++i)
    {
        ret *= t;
        t += one;
    }
    return ret.get();
}

u64 fact_mod_slow(int N, u64 mod)
{
    u64 ret = 1;
    for (int i = 1; i <= N; ++i)
        ret = mod128_64_small(u128(ret) * i, mod);
    return ret;
}

int main()
{
    int N;
    u64 M;
    scanf("%d %llu", &N, &M);// n! % m
    clock_t t0 = clock();
    u64 ans1 = fact_mod_slow(N, M);
    clock_t t1 = clock();
    u64 ans2 = fact_mod_fast(N, M);
    clock_t t2 = clock();
    printf("%llu %.3f sec\n", ans1, double(t1 - t0) / CLOCKS_PER_SEC);
    printf("%llu %.3f sec\n", ans2, double(t2 - t1) / CLOCKS_PER_SEC);
    return 0;
}
```



#### BM

```C++
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
// head

int _,n;
namespace linear_seq {
    const int N=10010;
    ll res[N],base[N],_c[N],_md[N];

    vector<int> Md;
    void mul(ll *a,ll *b,int k) {
        rep(i,0,k+k) _c[i]=0;
        rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;
        for (int i=k+k-1;i>=k;i--) if (_c[i])
            rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;
        rep(i,0,k) a[i]=_c[i];
    }
    int solve(ll n,VI a,VI b) { // a 系数 b 初值 b[n+1]=a[0]*b[n]+...
//        printf("%d\n",SZ(b));
        ll ans=0,pnt=0;
        int k=SZ(a);
        assert(SZ(a)==SZ(b));
        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;
        Md.clear();
        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);
        rep(i,0,k) res[i]=base[i]=0;
        res[0]=1;
        while ((1ll<<pnt)<=n) pnt++;
        for (int p=pnt;p>=0;p--) {
            mul(res,res,k);
            if ((n>>p)&1) {
                for (int i=k-1;i>=0;i--) res[i+1]=res[i];res[0]=0;
                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;
            }
        }
        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;
        if (ans<0) ans+=mod;
        return ans;
    }
    VI BM(VI s) {
        VI C(1,1),B(1,1);
        int L=0,m=1,b=1;
        rep(n,0,SZ(s)) {
            ll d=0;
            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;
            if (d==0) ++m;
            else if (2*L<=n) {
                VI T=C;
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                L=n+1-L; B=T; b=d; m=1;
            } else {
                ll c=mod-d*powmod(b,mod-2)%mod;
                while (SZ(C)<SZ(B)+m) C.pb(0);
                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;
                ++m;
            }
        }
        return C;
    }
    int gao(VI a,ll n) {
        VI c=BM(a);
        c.erase(c.begin());
        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;
        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));
    }
};

int main() {
    while (~scanf("%d",&n)) {
        vector<int>v;
        v.push_back(1);
        v.push_back(2);
            v.push_back(4);
        v.push_back(7);
        v.push_back(13);
        v.push_back(24);
        printf("%d\n",linear_seq::gao(v,n-1));
    }
}
```

#### 杜教筛

```c++
haha dfs(LL n) {
    if(n <= 17e5) return haha(phi[n],mu[n]);
    LL t = N / n;
    if(use[t] == cnt) return haha(phi2[t],mu2[t]);
    LL ansphi = n * (n + 1) / 2;
    LL ansmu = n >= 1;
    for(LL i = 2,r;i <= n;i = r + 1) {
        r = n / (n / i);
        haha tmp = dfs(n / i);
        ansphi -= tmp.first * (r - i + 1);
        ansmu -= tmp.second * (r - i + 1);
    }
    use[t] = cnt;
    return haha(phi2[t] = ansphi,mu2[t] = ansmu);
}
```



### 图论

给出度数序列$d_i$ ，求是否可以构成一个无向图。

对$d_i$ 递减排序，当且仅当对于任意的 k 满足：

*Erdős–Gallai theorem* : $\sum_{i=1}^k d_i \le k(k-1) + \sum_{i=k+1}^n \min(d_i,k) $

#### scc

```c++
void dfs(int u) {
    dfn[u] = low[u]= ++ dfs_clock;
    s.push(u);
    for(int i = head[u];i;i = nxt[i]) {
        int v = to[i];
        if(!dfn[v]) {
            dfs(v);
            low[u] = min(low[u],low[v]);
        }
        else if(!sccnum[v])
            low[u] = min(low[u],dfn[v]);
    }
    if(low[u] == dfn[u]) {
        scccnt ++;
        while(1) {
            int x = s.top(); s.pop();
            sccnum[x] = scccnt;
            sccsz[scccnt] ++;
            if(x == u) break;
        }
    }
}
```

#### 割点

```c++
void dfs(int u,int fa) {
    low[u] = dfn[u] = ++ dfs_clock;
    int c = 0;
    for(int i = head[u];i;i = nxt[i]) {
        int v = to[i];
        if(!dfn[v]) {
            dfs(v,u);
            c ++;
            low[u] = min(low[u],low[v]);
            if(low[v] >= dfn[u]) cut[u] = 1;
        }
        else if(dfn[v] < dfn[u]&&v != fa)
            low[u] = min(low[u],dfn[v]);
    }
    if(c == 1 && fa == 0) cut[u] = 0;
}
```



#### 桥

```c++
void tarjan(int u,int fa) {
    dfn[u] = low[u]= ++ dfs_clock;
    for(int i = head[u];i;i = nxt[i]) {
        int v = l[i].t;
        if(fa == v) continue;
        if(!dfn[v]) {
            tarjan(v,u);
            low[u] = min(low[u],low[v]);
            if(low[v] > dfn[u]) bcnt ++,bri[l[i].id] = 1;
        }
        else if(dfn[v] < dfn[u])
            low[u] = min(low[u],dfn[v]);
    }
}
void dfs(int u,int color) {
    c[u] = color;
    for(int i = head[u];i;i = nxt[i]) {
        int v = l[i].t;
        if(!bri[l[i].id] && !c[v])
            dfs(v,color);
    }
}
```



#### 圆方树

每个点双新建一个点（称为方点），连向点双内每个点。

圆点存原先信息，方点存点双信息。

例如：我现在有一张一般图，每个点有一个点权，要求从uu到vv的所有简单路径中经过的最小点权是多少。

可以建出圆方树，在每个方点上维护这个点双中的最小点权，那么每次询问就是查询一个路径最小值了。

单点修改权值方法：每个方点维护的信息中不包括它的父亲圆点，这样修改圆点的时候就只需要修改它的父亲方点。查询的时候如果路径的lcalca是个方点，就还要再算上它的父亲圆点。

````c++
void Tarjan(int u,int f) {
	dfn[u] = low[u] = ++ dfs_clock;
	S.push(u); ins[u] = 1;
	int child = 0;
	for(int i = 0;i < g2[u].size();i ++) {
		int v = g2[u][i];
		if(v == f) continue;
		if(!dfn[v]) {
			child ++;
			Tarjan(v,u);
			low[u] = min(low[u],low[v]);
			if(low[v] >= dfn[u]) {
				ccnt ++;
				cut[u] = 1;
				int x;
				do{
					x = S.top(); S.pop();
					ins[x] = 0;
					g[ccnt + n].push_back(x);
					g[x].push_back(ccnt + n);
				}while(x != v && !S.empty());
				g[ccnt + n].push_back(u);
				g[u].push_back(ccnt + n);
			}	
		}
		else if(ins[v]) {
			low[u] = min(low[u],dfn[v]);
		}
	}
	if(f == 0 && child == 1) cut[u] = 0;
}
````









#### 网络流

##### 最小割的可行边与必须边

首先不管是可行边还是必须边都要是满流边，因为最小割。

必须边：容量增大后最小割值增大。
必须边求法：跑完最小割后在残量网络上从源点dfs，汇点反向dfs，枚举起点被源点搜到、终点被汇点搜到的满流边就是答案。
另一种求法是tarjan。[鏼大爷](http://jcvb.is-programmer.com/posts/42972.html)Orz。

可行边好像只能tarjan？

tarjan求可行边、必须边（前提条件是满流）：
必须边：要求$sccnum[u]==sccnum[s] \text{  &&  }  sccnum[v]==sccnum[e]$。tarjan缩点后，若满足这个条件，那么扩大$<u,v>$的流量必能使最大流增大，所以是必须边。
可行边：要求$sccnum[u]!=sccnum[v]$，因为缩点后剩下的边只有满流边，任一割都满足这个条件，而这些边有可能会出现某一个最小割中，所以是可行边。

##### 最大流

以S-T流表示方案，根据题意把方案列上，要能在图中找到所有题目要求信息的体现。

##### 最小割

codevs1907方格取数3：二分图最大点权独立集=总边权-最小割。
相邻两格连INF边：防割。每次割的边表示不选，还可以保证冲突的点只选一个，保证是独立集。相当于去掉了最小点权覆盖集。

【bzoj1565】[NOI2009]植物大战僵尸：最大权闭合图=总正点权-最小割
源点向所有正点权为x的点建流量为x的边，负点权x的点向汇点建流量为-x的边，原图边容量INF。
证明略，详见胡伯涛论文。其中最大权闭合图在S集。

【poj2125】Destroying The Graph：二分图最小点权覆盖集=最小割
S连左部，容量为点权。右部连T，容量为点权。原边为INF。然后最小割。

最大点权独立集模型：对于一条边，要么只选u，要么只选v，要么都不选。

最小点权覆盖集模型：对于一条边，要么只选u，要么只选v，要么都选。

若有类似【最少的代价把集合分成两份】，可以考虑最小割。

##### 费用流

在最大流表示所有方案的基础上，费用流是从所有方案中择优选取。

bzoj1834网络扩容：
题目要求最少扩建费用。在残量网络上建边，只要原图存在的边（不管现在流量是不是0）都建流量为INF，费用为$w_i$的边，表示对这个边的扩建程度。还需要增加一个源点限制流量。



#### 最大流

无源汇上下界可行流

记录inb[u]表示u的入边的流量下界之和，outb[u]是u的出边的流量下界之和。

建图方法：

1.u到v建容量为C[u,v]-B[u,v]的边。
2.对于点u，记$tmp=inb[u]-outb[u]$。若tmp>0，则S向u建容量为tmp的边，若tmp<0，则u向e建容量为-tmp的边。

若满流则有解。

简单证明：设< u,v >边上的流量为f，则$\sum f = \sum （g + B）$，其中B是流量下界，g是超过下界的部分。g的范围是$[B,C]$，但容量设为$C-B$跑最大流不一定满足容量守恒，所以我们用流量守恒的式子得到：
$$\sum f_{<u,i>}=\sum f_{<i,v>} => \sum （g_{<u,i>} + B_{<u,i>}） =\sum （g_{<i,v>} + B_{<i,v>}） $$

设$M_i=\sum B_{<u,i>}-B_{<i,v>}$，也就是i点的tmp。
此时：

$$\sum g_{<i,v>} - \sum g_{<u,i>} = M_i$$

然后讨论：若$M_i<0$，$\sum g_{<u,i>} = \sum g_{<i,v>} - M_i$，则意义是进i号点的流需要多分出去$M_i$个，这就可以跑网络流了，大于0同理。

有源汇上下界可行流： 源汇之间连一条边当无源汇做。

有源汇上下界最大流：首先先做一个有源汇上下界可行流，然后再从残量网络上跑一个s到e的最大流就是答案。

有源汇上下界最小流：先判断是否有可行流，若有然后清空全图，重建图。

然后按【有源汇上下界可行流】的建图方法，但不建e到s的INF边，然后从超级源到超级汇跑最大流，然后再加上e到s的INF边，然后再跑一遍最大流，流经INF边的流量就是答案。

该算法的思想是在第一步中尽可能填充循环流，以减小最小流的代价。



```c++
bool bfs() {
    for(int i = 0;i <= e;i ++) deep[i] = 0;
    while(q.size()) q.pop();
    deep[s] = 1;
    q.push(s);
    while(q.size()) {
        int u = q.front(); q.pop();
        for(int i = head[u];i;i = nxt[i]) {
            int v = l[i].t;
            if(l[i].d && !deep[v]) {
                deep[v] = deep[u] + 1;
                if(v == e) return true;
                q.push(v);
            }
        }
    }
    return false;
}
LL dfs(int u,LL flow) {
    if(u == e || flow == 0) return flow;
    LL ans = flow;
    for(int i = head[u];i;i = nxt[i]) {
        int v = l[i].t;
        if(l[i].d && deep[v] == deep[u] + 1) {
            LL f = dfs(v,min(ans,l[i].d));
            if(f > 0) {
                l[i].d -= f;
                l[i ^ 1].d += f;
                ans -= f;
                if(ans == 0) break;
            }
            else deep[v] = 0;
        }
    }
    if(ans == flow) deep[u] = 0;
    return flow - ans;
}
LL dinic() {
    LL ans = 0;
    while(bfs()) {
        LL tmp = dfs(s,INF);
        if(tmp == 0) break;
        ans += tmp;
    }
    return ans;
}
```

#### zkw费用流

```c++
bool spfa() {
    memset(mark,0,sizeof(mark));
    memset(dist,-1,sizeof(dist));
    q.push(e); mark[e] = 1,dist[e] = 0;
    while(q.size()) {
        int u = q.front(); q.pop();
        mark[u] = 0;
        for(int i = head[u];i;i = nxt[i]) {
            int v = l[i].t;
            if(l[i ^ 1].d && dist[u] + l[i ^ 1].c > dist[v]) {
                dist[v] = dist[u] + l[i ^ 1].c;
                if(!mark[v]) mark[v] = 1,q.push(v);
            }
        }
    }
    return dist[s] != -1;
}
LL dfs(int x,LL f) {
    mark[x] = 1;
    if(x == e) return f;
    LL w,used = 0;
    for(int i = head[x];i;i = nxt[i]) {
        int v = l[i].t;
        if(dist[v] == dist[x] - l[i].c && l[i].d && !mark[v]) {
            w = f - used;
            w = dfs(v,min(w,l[i].d));
            ans += w * l[i].c;
            l[i].d -= w;l[i ^ 1].d += w;
            used += w; if(used == f) return f;
        }
    }
    return used;
}
void zkw() {
    while(spfa()) {
        memset(mark,0,sizeof(mark));
        mark[e] = 1;
        while(mark[e]){ mark[e] = 0; dfs(s,INF); }
    }
}
```



#### 二分图

二分图存在的充要条件（霍尔定理）：任意k个点所对应的点集的并集大于等于k。

##### 二分图的可行边与必须边

建新图。
对于边$<u,v>$，若是匹配边，则v向u连边；若是非匹配边，则u向v连边。
源汇点同理：若$<s,u>$是匹配边，则u向s连边，否则s向u连边。若$<u,e>$是匹配边，则e向u连边，否则u向e连边。

然后求scc，若边$<u,v>$是匹配边且在同一个scc中，则是可行边；若是匹配边但不在同一个scc中则是必须边。

##### 最小点覆盖=最大匹配

概念：二分图中选最少得点，使其覆盖所有的边。

可以贪心地去选点，使点出现在最大匹配上。

##### 最小边覆盖=顶点数-最小点覆盖

概念：二分图中选最少的边，使其覆盖所有点。

首先可以贪心地选最大匹配上的边，因为这样可以一条边覆盖两个点。剩下的点只能由其他边一条边覆盖一个点了。

设最大匹配数为m，选的其他边的数量是a，满足2m+a=n，答案是m+a=n-m，即最小边覆盖=顶点数-最小点覆盖。

##### 最大独立集=顶点数-最小点覆盖

概念：二分图中找一个最大点集，使得两点之间没有边。

去掉最少的点，剩下最多的点，使它们互相没有边。去掉的是点覆盖。

##### 最小路径覆盖=原图顶点数-拆点后最大匹配

概念：**有向无环图**中选出**不相交路径**覆盖所有点，求不相交路径最小值。

拆点：把每个点拆成入点和出点，然后对于边$< u,v >$，加边$< u,v'>$。

可以发现有向无环图中的一条边对应二分图中一条**匹配边**。
有向无环图中的每条边的出点（from）对应于二分图的**对应边匹配边左部点**。
每条路径最后一个点没有对应。

所以最小路径覆盖=路径最后一个点最最少=最少未匹配点=原图顶点数-拆点后最大匹配

###### 最大团=补图的最大独立集

定义二分图的最大团为左部若干点，右部若干点，且左右部两两连边。于是定理显然。

##### 构造可行解

对于最小点覆盖，从左部点的所有非匹配点开始找增广路。这样的增广路一定是非匹配边和匹配边交替的。最终所有访问过的右部点和未访问过的左部点构成最小点覆盖。其余点构成最大独立集。

```c++
bool dfs(int u) { // 每次搜完清vis
    for(int i = head[u];i;i = nxt[i]) {
        int v = to[i];
        if(!vis[v]) {
            vis[v] = 1;
            if(!match[v] || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}
```

#### KM

```c++
/// BFS版，跑得更快
/// uoj80
struct KuhnMunkres {
    int n; ///左部点和右部点的最大值
	LL f[SZ][SZ]; /// 邻接矩阵
	LL hl[SZ],hr[SZ],rst[SZ];
	int fl[SZ],fr[SZ]; /// fl:左部点对应匹配的右部点  fr反之。
	int vl[SZ],vr[SZ],pre[SZ],q[SZ],ql,qr;
	int check(int i) {
		if(vl[i]=1,fl[i]!=-1) return vr[q[qr++]=fl[i]]=1;
		while(i!=-1) swap(i,fr[fl[i]=pre[i]]);
		return 0;
	}
	void bfs(int s) {
		fill(rst+1,rst+n+1,INF),fill(vl+1,vl+n+1,0),fill(vr+1,vr+n+1,0);
		for(vr[q[ql=0]=s]=qr=1;;) {
			for(LL d; ql<qr;)
				for(int i=1,j=q[ql++]; i<=n; ++i)
					if(!vl[i]&&rst[i]>=(d=hl[i]+hr[j]-f[i][j]))
						if(pre[i]=j,d)rst[i]=d;
						else if(!check(i))return;
			LL d = INF;
			for(int i = 1;i <= n;i ++)
				if(!vl[i] && d>rst[i]) d=rst[i];
			for(int i = 1;i <= n;i ++) {
				if(vl[i]) hl[i] += d;
				else rst[i] -= d;
				if(vr[i]) hr[i] -= d;
			}
			for(int i=1; i<=n; ++i)
				if(!vl[i]&&!rst[i]&&!check(i))return;
		}
	}
	LL ask() {
		fill(fl+1,fl+n+1,-1),fill(fr+1,fr+n+1,-1),fill(hr+1,hr+n+1,0);
		for(int i=1;i<=n;i++) hl[i]=*max_element(f[i]+1,f[i]+n+1);
		for(int j=1;j<=n;j++) bfs(j);
        LL ans = 0;
        for(int i=1; i<=n; ++i) ans += f[i][fl[i]];
        return ans;
	}
} km;
```



#### 树剖

```c++
int find_max(int x,int y) {
    int fx = top[x],fy = top[y],ans = -INF;
    while(fx != fy) {
        if(deep[fx] < deep[fy]) swap(fx,fy),swap(x,y);
        ans = max(ans,ask_max(1,inseg[fx],inseg[x]));
        x = fa[fx],fx = top[x];
    }
    if(x != y) { //若是把边权放到点上，则有这一句
        if(deep[x] > deep[y]) swap(x,y);
        ans = max(ans,ask_max(1,inseg[x] + 1,inseg[y])); //若边权，则要+1
    }
    return ans;
}
```



#### 动态点分治

```c++
// 求标号在[l,r]内离u最近的的距离
vector<int> g[SZ];
void dfs_sz(int u,int f) {
    sz[u] = 1;
    for(int v : g[u]) {
        if(rt[v] || v == f) continue;
        dfs_sz(v,u);
        sz[u] += sz[v];
    }
}
int get_centroid(int u) {
    dfs_sz(u,0);
    int s = sz[u];
    while(1) {
        int found = 1;
        for(int v : g[u]) {
            if(rt[v] || sz[v] > sz[u]) continue;
            if(sz[v] * 2 >= s) {
                u = v; found = 0; break;
            }
        }
        if(found) return u;
    }
}
struct SegmentTree {
    struct seg {
        int l,r;
        int minn;
    };
    vector<seg> tree;
    vector<int> a;
    void update(int p) {
        tree[p].minn = min(tree[p<<1].minn,tree[p<<1|1].minn);
    }
    void build(int p,int l,int r,const vector<pii> &nodes) {
        tree[p].l = l;
        tree[p].r = r;
        if(l == r) {
            tree[p].minn = nodes[l-1].second;
            return ;
        }
        int mid = l + r >> 1;
        build(p<<1,l,mid,nodes);
        build(p<<1|1,mid+1,r,nodes);
        update(p);
    }
    int ask(int p,int l,int r) {
        if(l <= tree[p].l && tree[p].r <= r)
            return tree[p].minn;
        int mid = tree[p].l + tree[p].r >> 1,ans = 1e9;
        if(l <= mid) ans = min(ans,ask(p<<1,l,r));
        if(mid < r) ans = min(ans,ask(p<<1|1,l,r));
        return ans;
    }
    SegmentTree() { a.clear(); tree.clear(); }
    SegmentTree(const vector<pii> &nodes) {
        int n = nodes.size();
        tree.resize((n+1)*4);
        a.resize(n);
        for(int i = 0;i < nodes.size();i ++)
            a[i] = nodes[i].first;
        build(1,1,n,nodes);
    }
} st[SZ];
void dfs_dist(int u,int fa,int d) {
    nodes.push_back(make_pair(u,d));
    for(int v : g[u]) {
        if(rt[v] || v == fa) continue;
        dfs_dist(v,u,d+1);
    }
}
void process(int u) {
    nodes.clear();
    dfs_dist(u,0,0);
    for(pii p : nodes) {
        int x = p.first,dis = p.second;
        an[x].push_back(make_pair(u,dis));
    }
    sort(nodes.begin(),nodes.end());
    st[u] = SegmentTree(nodes);
}
void dfs(int u,int lst) {
    u = get_centroid(u);
    process(u);
    rt[u] = 1;
    for(int v : g[u]) {
        if(rt[v]) continue;
        dfs(v,u);
    }
}
int ask(int u,int l,int r) {
    int ans = 1e9;
    for(pii p : an[u]) {
        int x = p.first;
        int ll = lower_bound(st[x].a.begin(),st[x].a.end(),l) - st[x].a.begin() + 1;
        int rr = upper_bound(st[x].a.begin(),st[x].a.end(),r) - st[x].a.begin();
        if(ll <= rr) {
            ans = min(ans,p.second + st[x].ask(1,ll,rr));
        }
    }
    return ans;
}
```

#### 欧拉路

```c++
void dfs(int u) {  //注意路是倒着的
    for(int i = 0;i < g[u].size();i ++) {
        int v = g[u][i].t,id = g[u][i].id;
        if(use[id]) continue;
        use[id] = 1;
        dfs(v);
        p[++ p[0]] = g[u][i].id;
    }
}
```

#### k短路

```c++
namespace kpath {
	int n,m;
	
	struct edge {
		int t; LL d;
	};
	vector<edge> g[SZ],g2[SZ];
	
	LL dist[SZ];
	int pre[SZ];	
	struct Heap{ int u; LL d; };
	bool operator <(Heap a,Heap b) { return a.d > b.d; }
	priority_queue<Heap> q;

	int rd[SZ];
	stack<int> S;
	void topo(int s) {  //反向跑最短路，对于DAG可以toposort，否则只能dij/spfa
		for(int i = 1;i <= n;i ++) dist[i] = INF,pre[i] = 0;
		S.push(s); dist[s] = 0;
		while(S.size()) {
			int u = S.top(); S.pop();
			for(int i = 0;i < g2[u].size();i ++) {
				int v = g2[u][i].t;
				if(dist[v] > dist[u] + g2[u][i].d)
					dist[v] = dist[u] + g2[u][i].d,pre[v] = u;
				if(!-- rd[v]) S.push(v);
			}
		}
	}
	
	struct node{ int lc,rc,dis,id; LL v; }tree[SZ * 12];
	int tot,rt[SZ];
	int merge(int x,int y) {
		if(!x||!y) return x + y;
		if(tree[x].v > tree[y].v) swap(x,y);
		int o = ++ tot; tree[o] = tree[x];
		tree[o].rc = merge(tree[o].rc,y);
		if(tree[tree[o].lc].dis < tree[tree[o].rc].dis) swap(tree[o].lc,tree[o].rc);
		tree[o].dis = tree[tree[o].rc].dis + 1;
		return o;
	}	
	void dfs(int u) {
		if(pre[u]) rt[u] = rt[pre[u]];
		for(int i = 0;i < g[u].size();i ++) {
			int v = g[u][i].t;
			if(dist[v] == INF || pre[u] == v) continue;
			tree[++ tot] = (node){0,0,1,v,dist[v]+g[u][i].d-dist[u]};
			rt[u] = merge(rt[u],tot);
		}
		for(int i = 0;i < g2[u].size();i ++)
			if(pre[g2[u][i].t] == u) dfs(g2[u][i].t);
	}
	
	int ff[SZ],tt[SZ],dd[SZ];
	LL work(int s,int e,int k) {
		for(int i = 1;i <= m;i ++) {
			g[ff[i]].push_back((edge){tt[i],dd[i]});
			g2[tt[i]].push_back((edge){ff[i],dd[i]});
			rd[ff[i]] ++;
		}
		topo(e); 
		tot = rt[e] = 0; dfs(e);
		if(k == 1) return -dist[s];
		while(q.size()) q.pop();
		q.push((Heap){rt[s],dist[s] + tree[rt[s]].v});
		while(k --) {
			Heap p = q.top(); q.pop();
			if(k == 1) return -p.d;
			int u = p.u,v = tree[u].id;
			if(rt[v]) q.push((Heap){rt[v],p.d + tree[rt[v]].v});
			if(tree[u].lc) q.push((Heap){tree[u].lc,p.d - tree[u].v + tree[tree[u].lc].v});
			if(tree[u].rc) q.push((Heap){tree[u].rc,p.d - tree[u].v + tree[tree[u].rc].v});
		}
	}
	void init(int nn){ 
		n = nn; m = 0;
		for(int i = 1;i <= n;i ++) g[i].clear(),g2[i].clear();
	}
}
```

#### dsu on tree

```c++
/*
dsu on tree：无修改子树问题。每个点可以O(1)删除/加入贡献。先递归计算轻儿子，再把它们的贡献消除，再计算重儿子，再合并轻儿子，此时计算该子树贡献。如果当前子树是父节点的轻子树，则消除。
*/
//hdu6430 节点u的权值为max{gcd(vi,vj)},i和j的lca为u。求每个点的权值。
void dfs2(int u) {
    for(int i = 0;i < val[u].size();i ++) {
        int x = val[u][i];
        tmp.push_back(x);
    }
    for(int i = 0;i < g[u].size();i ++) {
        int v = g[u][i];
        dfs2(v);
    }
}
void dfs(int u,bool c) { //c:u是否是它父亲的重儿子。
    for(int i = 0;i < g[u].size();i ++) {
        int v = g[u][i];
        if(v != son[u])
            dfs(v,0);
    }
    if(son[u]) dfs(son[u],1);
    ans[u] = -1;
    for(int i = 0;i < val[u].size();i ++) {
        int x = val[u][i];
        if(a[x]) ans[u] = max(ans[u],x);
        a[x] ++;
    }
    for(int i = 0;i < g[u].size();i ++) {
        int v = g[u][i];
        if(v == son[u]) continue;
         tmp.clear();
         dfs2(v);
        for(int j = 0;j < tmp.size();j ++) {
            int x = tmp[j];
            if(a[x]) ans[u] = max(ans[u],x);
        }
        for(int j = 0;j < tmp.size();j ++) a[tmp[j]] ++;
    }
    if(!c) {
        tmp.clear();
        dfs2(u);
        for(int j = 0;j < tmp.size();j ++) a[tmp[j]] --;
    }
}
```



#### 单纯形

```c++
///a[i][j]:i表第几条约束 j表第几个元素
///a[0][i] -> ci 目标函数中第i个元素系数
///a[i][0] -> bi 第i条约束中的常数
///a[i][j] -> Aij 第i条约束中第j个元素的系数
///最大化 sigma(ci*xi),i∈N
///约束 xj=bj-sigma(aji*xi) ,j∈B
namespace dcx {
	int n,m,id[2010];
	double a[50][1100];
	void pivot(int l,int e) { //换入变量l∈[1,n]，替出变量e∈[n+1,n+m]
		swap(id[n + l],id[e]);
		double t = a[l][e]; a[l][e] = 1;
		for(int j = 0;j <= n;j ++) a[l][j] /= t;
		for(int i = 0;i <= m;i ++) { //重写其他式子
			if(i != l && fabs(a[i][e]) > eps) {
				t = a[i][e]; a[i][e] = 0;
				for(int j = 0;j <= n;j ++)
					a[i][j] -= a[l][j] * t;
			}
		}
	}
	bool init() {  //初始化
		while(233) {
			int e = 0,l = 0;
			for(int i = 1;i <= m;i ++)
				if(a[i][0] < -eps && !l)
					l = i;
			if(!l) break;
			for(int j = 1;j <= n;j ++)
				if(a[l][j] < -eps && !e)
					e = j;
			if(!e) {return false; }  //无解
			pivot(l,e);
            //在bi为负的时候，把所有基变量设为0不是一组合法的初始解
        	//所以选择一个bi为负的基变量x[i+n]
        	//然后在该约束右边找一个系数为正(即原系数为负)的非基变量进行转轴操作
        	//如果没有系数为正显然就无解了
		}
		return true;
	}
	bool simplex() {  //主程序
		for(int i = 1;i <= n + m;i ++) id[i] = i;
		if(!init()) return false;
		while(233) {
			int l = 0,e = 0;
			double Min = 1e100;
			for(int j = 1;j <= n;j ++)
				if(a[0][j] > eps) { e = j; break; }
			if(!e) break;
			for(int i = 1;i <= m;i ++)
				if(a[i][e] > eps && a[i][0] / a[i][e] < Min)
					Min = a[i][0] / a[i][e],l = i;
			if(!l) { return false; }
			pivot(l,e);
		}
		return true;
	}
}
```



### 数据结构

三维偏序：sort+cdq+树状数组，四维偏序：sort+cdq+cdq+树状数组。

bitset做k维偏序：`f[i][j]`表示第i维的值的排名小于等于j*block的编号集合，这样可以找到第i维的值小于某个值的编号集合Si。对于每个k维向量，小于等于它的个数即Si求交。

#### 笛卡尔树

```c++
void build() { //l r : i的左儿子/右儿子
    for(int i = 1;i <= n;i ++) l[i] = r[i] = 0;
    int top = 0;
    for(int i = 1;i <= n;i ++) {
        int k = top;
        while(k && a[S[k]] < a[i]) k --;
        if(k) r[S[k]] = i;
        if(k < top) l[i] = S[k + 1];
        top = k;
        S[++ top] = i;
    }
}
```

#### 整体二分（K大数查询）

```c++
/*
整体二分：1.多组询问可以离线。2.单组询问可以二分答案，check对于单组可接受。3.修改对判定答案贡献独立。4.贡献与判定标准无关。5.贡献满足交换律、结合律，具有可加性。
*/
void solve(int vl,int vr,int l,int r) { // 每个位置加入x，查询区间k大
    if(vl > vr || l > r) return ;
    if(vl == vr) {
        for(int i = l;i <= r;i ++)
            if(a[i].type == 2) Ans[a[i].id] = vl;
        return ;
    }
    int vm = vl + vr >> 1;
    int pl = 0,pr = 0;
    for(int i = l;i <= r;i ++) {
        if(a[i].type == 1) {
            if(a[i].k <= vm) change(1,a[i].l,a[i].r,1),tmpl[++ pl] = a[i];
            else tmpr[++ pr] = a[i];
        }
        else {
            LL x = ask(1,a[i].l,a[i].r);
            if(a[i].k <= x) tmpl[++ pl] = a[i];
            else a[i].k -= x,tmpr[++ pr] = a[i];
        }
    }
    for(int i = 1;i <= pl;i ++) if(tmpl[i].type == 1) change(1,tmpl[i].l,tmpl[i].r,-1);
    for(int i = 1;i <= pl;i ++) a[l + i - 1] = tmpl[i];
    for(int i = 1;i <= pr;i ++) a[l + pl + i - 1] = tmpr[i];
    solve(vl,vm,l,l+pl-1); solve(vm+1,vr,l+pl,r);
}
```

#### cdq分治

```c++
void cdq(int l,int r) {
    if(l >= r) return ;
    int mid = l + r >> 1;
    cdq(l,mid); cdq(mid + 1,r);
    int pl = l,pr = mid + 1,p = l;
    while(pl <= mid || pr <= r) {
        if(pr > r || (pl <= mid && a[pl].y <= a[pr].y)) {
            Add(a[pl].z,a[pl].val); 
            tmp[p ++] = a[pl ++];
        }
        else {
            a[pr].ans += Ask(a[pr].z); 
            tmp[p ++] = a[pr ++];
        }
    }
    for(int i = l;i <= r;i ++) {
        if(i <= mid) Add(a[i].z,-a[i].val);
        a[i] = tmp[i];
    }
}
```

#### 7维偏序

```c++
int a[8][SZ],f[8][SZ],B;
bitset<SZ> num[8][250];
 
bitset<SZ> get(int k,int pos) {
	bitset<SZ> ans; ans.reset();
	if(pos / B - 1 >= 0) ans = num[k][pos / B - 1];
	for(int i = max(1,(pos / B - 1) * B + 1);i <= pos;i ++)
		ans.set(a[k][i]);
	return ans;
}
 
int main() {
	int n = read(),k = read();
	B = sqrt(n);
	for(int i = 0;i <= k;i ++) {
		for(int j = 1;j <= n;j ++) {
			if(i == 0) { a[i][j] = f[i][j] = j; continue; }
			f[i][j] = read();
			a[i][f[i][j]] = j;
		}
	}
	for(int j = 0;j <= k;j ++) {
		bitset<SZ> tmp; tmp.reset();
		for(int i = 1;i <= n;i ++) {
			tmp.set(a[j][i]);
			if(i == n || i / B != (i + 1) / B) num[j][i / B] = tmp;
		}
	}
	LL ans = 0;
	for(int i = 1;i <= n;i ++) {
		bitset<SZ> w; w.set();
		for(int j = 0;j <= k;j ++) {
			w &= get(j,f[j][i] - 1);
		}
		ans += w.count();
	}
	cout << ans << endl;
	return 0;
}
```

#### 二维st表

```cpp
void get_st()
{
    memset(st,0,sizeof(st));
    for(int i = 1;i <= n;i ++)
        for(int j = 1;j <= m;j ++)
            st[i][j][0][0] = a[i][j];

    for(int l = 1;(1 << l) <= m;l ++)
        for(int i = 1;i <= n;i ++)
            for(int j = 1;j <= m - (1 << (l - 1));j ++)
                st[i][j][0][l] = max(st[i][j][0][l - 1],st[i][j + (1 << (l - 1))][0][l - 1]);

    for(int k = 1;(1 << k) <= n;k ++)
        for(int i = 1;i <= n - (1 << (k - 1));i ++)
            for(int j = 1;j <= m;j ++)
                st[i][j][k][0] = max(st[i][j][k - 1][0],st[i + (1 << (k - 1))][j][k - 1][0]);

    for(int k = 1;(1 << k) <= n;k ++)
        for(int l = 1;(1 << l) <= m;l ++)
            for(int i = 1;i <= n - (1 << (k - 1));i ++)
                for(int j = 1;j <= m - (1 << (l - 1));j ++)
                    st[i][j][k][l] = max(max(st[i][j][k - 1][l - 1],st[i + (1 << (k - 1))][j][k - 1][l - 1]),
                                         max(st[i][j + (1 << (l - 1))][k - 1][l - 1],st[i + (1 << (k - 1))][j + (1 << (l - 1))][k - 1][l - 1]));
}

int ask_max(int x1,int y1,int x2,int y2)
{
    int k = log2(x2 - x1 + 1),l = log2(y2 - y1 + 1);
    int ans1 = max(st[x1][y1][k][l],st[x1][y2 - (1 << l) + 1][k][l]);
    int ans2 = max(st[x2 - (1 << k) + 1][y1][k][l],st[x2 - (1 << k) + 1][y2 - (1 << l) + 1][k][l]);
    return max(ans1,ans2);
}

```

#### 左偏树

```cpp
int n,m,use[SZ];

struct Heap {
    int lc,rc,w2,d;
    LL w1;
}tree[SZ];

int merge(int x,int y) {
    if(!x || !y) return x + y;
    if(tree[x].w1 > tree[y].w1 || (tree[x].w1 == tree[y].w1 && tree[x].w2 > tree[y].w2)) swap(x,y);
    tree[x].rc = merge(tree[x].rc,y);
    if(tree[tree[x].rc].d > tree[tree[x].lc].d) swap(tree[x].rc,tree[x].lc);
    tree[x].d = tree[tree[x].rc].d + 1;
    return x;
}

int pop(int x) {
    int l = tree[x].lc,r = tree[x].rc;
    tree[x].d = tree[x].lc = tree[x].rc = 0;
    return merge(l,r);
}

int fa[SZ];
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }

int main() {
    n = read(), m = read();
    tree[0].lc = tree[0].rc = tree[0].w1 = tree[0].w2 = 0;
    tree[0].d = -1;
    for(int i = 1;i <= n;i ++) {
        tree[i].w1 = read(); tree[i].w2 = fa[i] = i;
        tree[i].d = tree[i].lc = tree[i].rc = 0;
    }
    while(m --) {
        int opt = read(),x = read(),y;
        if(opt == 1) {
            y = read();
            if(use[x] || use[y]) continue;
            x = find(x),y = find(y);
            int xx;
            if(x != y) xx = merge(x,y),fa[y] = fa[x] = xx;
        }
        else {
            if(use[x]) { puts("-1"); continue; }
            x = find(x);
            use[tree[x].w2] = 1;
            printf("%lld\n",tree[x].w1);
            tree[x] = tree[pop(x)];
        }
    }
}
```

```cpp
int n,m,use[SZ];

struct node {
    node *lc,*rc;
    int id,dis;
    LL w;
    node(LL x,int i):w(x),id(i) { dis = 0; lc = rc = NULL; }
    int dist() { return this == NULL ? -1 : dis; }
}*rt[SZ];


node* merge(node *x,node *y) {
    if(!y) return x;
    if(!x) return y;
    if(x -> w > y -> w || (x -> w == y -> w && x -> id > y -> id)) swap(x,y);
    x -> rc = merge(x -> rc,y);
    if(x -> rc -> dist() > x -> lc -> dist()) swap(x -> rc,x -> lc);
    x -> dis = x -> rc -> dist() + 1;
    return x;
}

void pop(node* &x) {
    node *p = x;
    use[x -> id] = 1;
    x = merge(x -> lc,x -> rc);
    delete p;
}

int fa[SZ];
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }

int main() {
    n = read(), m = read();
    for(int i = 1;i <= n;i ++)
        rt[i] = new node(read(),i),fa[i] = i;
    while(m --){
        int opt = read(),x = read(),y;
        if(opt == 1) {
            y = read();
            if(use[x] || use[y]) continue;
            x = find(x),y = find(y);
            if(x != y) rt[x] = merge(rt[x],rt[y]),fa[y] = x;
        }
        else {
            if(use[x]) { puts("-1"); continue; }
            x = find(x);
            printf("%lld\n",rt[x] -> w);
            pop(rt[x]);
        }
    }
}
```

#### 线段树合并

```cpp
namespace Seg {
    struct segment {
        int lc,rc,sz;
        LL sum,ans;
    }tree[1670000];
    int Segsz = 0;
    int newnode(){
        int p = ++ Segsz;
        tree[p].lc = tree[p].rc = 0;
        tree[p].sz = tree[p].sum = tree[p].ans = 0;
        return p;
    }
    void update(int p) {
        tree[p].sz = tree[tree[p].lc].sz + tree[tree[p].rc].sz;
        tree[p].sum = tree[tree[p].lc].sum + tree[tree[p].rc].sum;
        tree[p].ans = tree[tree[p].lc].ans + tree[tree[p].rc].ans;
    }
    void insert(int &p,int l,int r,int x) {
        if(!p) p = newnode();
        if(l == r) { tree[p].sz = 1; tree[p].ans = tree[p].sum = lsh[x]; return ;}
        int mid = l + r >> 1;
        if(x <= mid) insert(tree[p].lc,l,mid,x);
        else insert(tree[p].rc,mid + 1,r,x);
        update(p);
    }
}
using namespace Seg;
int merge(int x,int y) {
    if(!x) return y;
    if(!y) return x;
    tree[x].lc = merge(tree[x].lc,tree[y].lc);
    tree[x].rc = merge(tree[x].rc,tree[y].rc);
    tree[x].sz += tree[y].sz; tree[x].sum += tree[y].sum;
    if(!tree[x].lc && !tree[x].rc) tree[x].ans = (tree[x].sz + 1) * tree[x].sum >> 1ll;
    else tree[x].ans = tree[tree[x].lc].ans + tree[tree[x].rc].ans + tree[tree[x].lc].sum * tree[tree[x].rc].sz;
    return x;
}
void dfs(int u,int f) {
    int x = lower_bound(lsh + 1,lsh + 1 + m,val[u]) - lsh;
    insert(root[u],1,m,x);
    for(int i = 0;i < g[u].size();i ++) {
        int v = g[u][i];
        if(v == f) continue;
        dfs(v,u);
        root[u] = merge(root[u],root[v]);
    }
}
void init() {
    Segsz = 0;
    for(int i = 0;i < 100001;i ++) root[i] = 0,g[i].clear();
    memset(tree,0,sizeof(tree));
}
int main() {
    int T = read();
    while(T --) {
        init();
        n = read();
        for(int i = 1;i <= n;i ++) val[i] = read(),lsh[i] = val[i];
        sort(lsh + 1,lsh + 1 + n);
        m = unique(lsh + 1,lsh + 1 + n) - lsh - 1;
        for(int i = 1;i < n;i ++) {
            int x = read(),y = read();
            g[x].push_back(y);
            g[y].push_back(x);
        }
        dfs(1,0);
        for(int i = 1;i <= n;i ++)
            printf("%lld ",tree[root[i]].ans);
        puts("");
    }
    return 0;
}
```

#### Splay

```c++
// 维修数列，支持区间插入、删除、翻转、修改、求和、求最大子段和
struct node{
    node *f,*ch[2];
    int v,sz,cnt,sum,lx,rx,mx;
    bool same,rev;

    void setc(node *x,int d) { (ch[d] = x) -> f = this; }
    int dir() { return f -> ch[1] == this; }
    void pushdown();
    void maintain() {
        sz = ch[0] -> sz + ch[1] -> sz + cnt;
        sum = ch[0] -> sum + ch[1] -> sum + v;
        lx = max(ch[0] -> lx,ch[0] -> sum + v + max(ch[1] -> lx,0));
        rx = max(ch[1] -> rx,ch[1] -> sum + v + max(ch[0] -> rx,0));
        mx = max(max(ch[0] -> mx,ch[1] -> mx),max(ch[0] -> rx,0) + v + max(ch[1] -> lx,0));
    }
}T[SZ], *root, *null;
node* newnode(int v,node *f) {
    int cnt;
    if(Tcnt2) cnt = sa[Tcnt2 --];
    else cnt = Tcnt1++;
    node *k = T + cnt;
    k -> ch[0] = k -> ch[1] = null;
    k -> f = f;
    k -> v = k -> sum = k -> lx = k -> rx = k -> mx = v;
    k -> sz = k -> cnt = 1;
    k -> same = k -> rev = 0;
    return k;
}
void pushdrev(node *p) {
    if(p == null) return ;
    swap(p -> ch[0],p -> ch[1]);
    swap(p -> lx,p -> rx);
    p -> rev ^= 1;
}
void pushdsame(node *p,int v) {
    if(p == null) return ;
    p -> same = 1;
    p -> sum = v * p -> sz;
    p -> v = v;
    p -> mx = p -> lx = p -> rx = max(v,p -> sum);
}
void node::pushdown() {
    if(this == null) return ;
    if(rev) { pushdrev(ch[0]); pushdrev(ch[1]); rev = 0; }
    if(same) { pushdsame(ch[0],v); pushdsame(ch[1],v); same = 0; }
}
void rotate(node *p) {
    node *fa = p -> f;
    int d = p -> dir();
    fa -> f -> setc(p,fa -> dir());
    fa -> setc(p -> ch[d ^ 1],d); fa -> maintain();
    p -> setc(fa,d ^ 1); p -> maintain();
    if(fa == root) root = p;
}
void splay(node *p,node *rt = null) {
    p -> pushdown();
    while(p -> f != rt) {
        if(p -> f -> f == rt) rotate(p);
        else {
            p -> f -> f -> pushdown(); p -> f -> pushdown(); p -> pushdown();
            if(p -> dir() == p -> f -> dir()) rotate(p -> f),rotate(p);
            else rotate(p),rotate(p);
        }
    }
    p -> maintain();
}
node* find(node *p,int k) { // find_kth
    while(p != null) {
        p -> pushdown();
        int l = p -> ch[0] -> sz + 1; 
        int r = p -> ch[0] -> sz + p -> cnt;
        if(l <= k && k <= r) return p;
        if(k > r) k -= r,p = p -> ch[1];
        else p = p -> ch[0]; 
    }
}
void build(node* &p,int l,int r,node *fa) {
    if(l > r) return ;
    int mid = (l + r) >> 1;
    p = newnode(num[mid],fa);
    build(p -> ch[0],l,mid - 1,p);
    build(p -> ch[1],mid + 1,r,p);
    p -> maintain();
}
void insert(int pos,int tot) {
    pos ++;
    for(int i = 1;i <= tot;++ i) scanf("%d",&num[i]);
    splay(find(root,pos)); splay(find(root,pos + 1),root);
    build(root -> ch[1] -> ch[0],1,tot,root -> ch[1]);
    root -> ch[1] -> maintain();
    root -> maintain();
}
void dfs(node *p) {
    if(p == null) return ;
    sa[++ Tcnt2] = p - T;
    dfs(p -> ch[0]);
    dfs(p -> ch[1]);
}
void reverse(int l,int r) {
    l ++,r ++;
    splay(find(root,l - 1));    splay(find(root,r + 1),root);
    pushdrev(root -> ch[1] -> ch[0]);
    root -> ch[1] -> maintain();
    root -> maintain(); 
}
void init() {
    null = newnode(-INF,null);
    null -> cnt = null -> sz = 0;
    root = newnode(-INF,null);
    root -> ch[1] = newnode(-INF,root);
    root -> sum = null -> sum = root -> ch[1] -> sum = 0;
    root -> maintain();
}
```

```c++
// 基本操作，支持插入删除查询k大等等
struct node {
    node *f,*ch[2];
    int v,sz,cnt;
    void setc(node *x,int d) { (ch[d] = x) -> f = this; }
    int dir() { return f -> ch[1] == this; }
    void maintain() {
        sz = ch[0] -> sz + cnt + ch[1] -> sz;
    }
    int cmp(int x) {
        if(x == v) return -1;
        return x < v ? 0 : 1;
    }
    void pushdown() {} ;
}T[SZ], *root, *null;
node* newnode(int x,node *fa) {
    node *k = T + Tcnt ++;
    k -> f = fa;
    k -> ch[0] = k -> ch[1] = null;
    k -> v = x;
    k -> cnt = k -> sz = 1;
    return k;
}
void rotate(node *p) {
    node *fa = p -> f;
    int d = p -> dir();
    fa -> f -> setc(p,fa -> dir());
    fa -> setc(p -> ch[d ^ 1],d); fa -> maintain();
    p -> setc(fa,d ^ 1); p -> maintain();
}
void splay(node *p,node *rt = null) {
    p -> pushdown();
    while(p -> f != rt) {
        if(p -> f -> f == rt) rotate(p);
        else {
            p -> f -> f -> pushdown(); p -> f -> pushdown(); p -> pushdown();
            if(p -> dir() == p -> f -> dir()) rotate(p -> f),rotate(p);
            else rotate(p),rotate(p);
        }
    }
    p -> maintain();
}
void insert(node *p,int x,node* &root) {
    if(root == null) { root = newnode(x,null); return ; }
    while(p != null) {
        p -> sz ++;
        int d = p -> cmp(x);
        if(d == -1) { p -> cnt ++; break; }
        if(p -> ch[d] == null) {
            p -> ch[d] = newnode(x,p);
            p = p -> ch[d];
            break;
        }
        p = p -> ch[d];
    }
    splay(p);
    while(root -> f != null) root = root -> f;
}
void erase(node *p,int x,node* &root) {
    while(p != null) {
        p -> sz --;
        int d = p -> cmp(x);
        if(d == -1) { p -> cnt --; break;}
        p = p -> ch[d];
    }
    if(p -> cnt) return ;
    splay(p);
    while(root -> f != null) root = root -> f;
    if(p -> ch[1] == null) { root = p -> ch[0],root -> f = null; return ; }
    if(p -> ch[0] == null) { root = p -> ch[1],root -> f = null; return ; }
    p = p -> ch[0];
    while(p -> ch[1] != null) p = p -> ch[1];
    splay(p,root);
    p -> ch[1] = root -> ch[1]; p -> ch[1] -> f = p;
    p -> f = null; p -> maintain();
    root = p;
}
int ask_num(int k) {
    node *p = root;
    while(p != null) {
        int l = p -> ch[0] -> sz + 1;
        int r = p -> ch[0] -> sz + p -> cnt;
        if(l <= k && k <= r) return p -> v;
        if(k > r) k -= r,p = p -> ch[1];
        else p = p -> ch[0];
    }
}
int ask_rank(int x) {
    node *p = root;
    int ans = 0;
    while(p != null) {
        int d = p -> cmp(x);
        if(d == -1) return ans + p -> ch[0] -> sz + 1;
        if(d == 1) ans += p -> ch[0] -> sz + p -> cnt;
        p = p -> ch[d];
    }
    return -1;
}
int ask_pre(int x) {
    node *p = root;
    int ans = 0;
    while(p != null) {
        if(p -> v < x) ans = p -> v,p = p -> ch[1];
        else p = p -> ch[0];
    }
    return ans;
}
int ask_suf(int x) {
    node *p = root;
    int ans = 0;
    while(p != null) {
        if(p -> v > x) ans = p -> v,p = p -> ch[0];
        else p = p -> ch[1];
    }
    return ans;
}
void init() {
    null = newnode(-INF,null);
    null -> sz = null -> cnt = 0;
    root = null;
}

```

#### LCT

定义操作access(u)，表示从u为起点，向当前树的根节点连一条重链，这条重链的端点分别为当前树的根节点和u。

对于每一条重链，我们用一棵Splay维护，关键字为重链上点的深度。

然后，对于操作access(u)，可以高效地利用splay做到。

access操作：

![这里写图片描述](http://img.blog.csdn.net/20160105193826691)

相当于把沿途的重链所组成的splay断开，接上N节点所拉的重链。

换根（toroot(u)）：若想让u成为当前树的根节点，则可以先access(u)，再splay(u)，把u转为当前splay的根节点。因为splay维护的是深度，所以u没有右儿子（没有比u还要深的点，因为重链定义），所以换根就相当于一次区间翻转，交换左右子树即完成区间翻转。此时就可以打标记了。

这样，toroot(u)操作的过程，就是先access(u)，再splay(u)，再翻转。

提取u到v的路径，可以先toroot(u)，再access(v)，此时v到根节点u所拉的重链即为所求路径，也就是整棵splay。

但标记下放有一个问题。因为splay是时时刻刻在分裂与合并的，因为要动态维护每条重链，所以在splay之前，要先把根节点到当前节点全部下放一遍标记，防止标记下放不完全。

![这里写图片描述](http://img.blog.csdn.net/20160105195934662)

```c++
// 连边、删边、单点修改、查询链异或和
struct node{
    node *f,*ch[2];
    int ans,v;
    bool rev;
    void maintain() {
        ans = ch[0] -> ans ^ ch[1] -> ans ^ v;
    }
    void setc(node *x,int d) { (ch[d] = x) -> f = this; }
    void pushdown();
    int dir() { return f -> ch[1] == this; }
    bool isroot() { return f -> ch[0] != this && f -> ch[1] != this; }
}T[SZ], *null, *tree[SZ];
node* newnode(int x) {
    node *k = T + (Tcnt ++);
    k -> ch[0] = k -> ch[1] = k -> f = null;
    k -> v = k -> ans = x;
    k -> rev = 0;
    return k;
}
void pushrev(node *p) { if(p == null) return; swap(p -> ch[0],p ->ch[1]); p -> rev ^= 1; }
void node :: pushdown() {
    if(rev) { pushrev(ch[0]); pushrev(ch[1]); rev = 0; }
}
void rotate(node *p) {
    node *fa = p -> f;
    int d = p -> dir();
    p -> f = fa -> f;
    if(!fa -> isroot()) p -> f -> ch[fa -> dir()] = p;
    fa -> ch[d] = p -> ch[d ^ 1];
    if(fa -> ch[d] != null) fa -> ch[d] -> f = fa;
    p -> setc(fa,d ^ 1);
    fa -> maintain(); p -> maintain();
}
void pushpath(node *p) {
    int top = 0;
    while(!p -> isroot()) S[++ top] = p,p = p -> f;
    S[++ top] = p;
    while(top) S[top --] -> pushdown();
}

void splay(node *p) {
    pushpath(p);
    while(!p -> isroot()) {
        if(p -> f -> isroot()) rotate(p);
        else {
            if(p -> dir() == p -> f -> dir()) rotate(p -> f),rotate(p);
            else rotate(p),rotate(p);
        }
    }
    p -> maintain();
}
void access(node *p) {
    node *last = null;
    while(p != null) {
        splay(p);
        p -> ch[1] = last; p -> maintain();
        last = p;
        p = p -> f;
    }
}

void toroot(node *p) {
    access(p); splay(p); pushrev(p);
}

void link(node *u,node *v) {
    toroot(u); u -> f = v;
}
void cut(node *u,node *v) {
    toroot(u);
    access(v);
    splay(v);
    if(v -> ch[0] == u && u -> ch[1] == null)
        v -> ch[0] = u -> f = null,v -> maintain();
}
void change(node *p,int v) {
    access(p); splay(p); p -> v = v; p -> maintain();
}
node* find_root(node *p) {
    while(p -> f != null) p = p -> f; return p;
}
int ask_xor(node *u,node *v) {
    toroot(u); access(v); splay(v);
    return v -> ans;
}
void init() { null = newnode(0); }
```



#### 树状数组套主席树

```c++
struct node{
    int l,r;
    int cnt;
}tree[5000000];
void insert(int l,int r,int last,int &now,int v,int x) {
    now = ++ Tcnt;
    tree[now] = tree[last];
    tree[now].cnt += x;
    if(l == r) return;
    int mid = (l + r) >> 1;
    if(v <= mid) insert(l,mid,tree[last].l,tree[now].l,v,x);
    else insert(mid + 1,r,tree[last].r,tree[now].r,v,x);
}
void change(int pos,int v,int x) {
    for(int i = pos;i <= n;i += (i & -i))
        insert(1,len,rt[i],rt[i],v,x);
}
int query(int l,int r,int k) {
    if(l == r) return l;
    int suml = 0,sumr = 0;
    for(int i = 1;i <= tl;i ++) suml += tree[tree[tml[i]].l].cnt;
    for(int i = 1;i <= tr;i ++) sumr += tree[tree[tmr[i]].l].cnt;
    int mid = l + r >> 1;
    if(sumr - suml >= k) {
        for(int i = 1;i <= tl;i ++) tml[i] = tree[tml[i]].l;
        for(int i = 1;i <= tr;i ++)
            tmr[i] = tree[tmr[i]].l;
        return query(l,mid,k);
    }
    else {
        for(int i = 1;i <= tl;i ++)
            tml[i] = tree[tml[i]].r;
        for(int i = 1;i <= tr;i ++)
            tmr[i] = tree[tmr[i]].r;
        return query(mid + 1,r,k - (sumr - suml));      
    }
}
int askk(int l,int r,int k) {
    l --;
    tl = tr = 0;
    for(int i = l;i > 0;i -= (i & -i)) tml[++ tl] = rt[i];
    for(int i = r;i > 0;i -= (i & -i)) tmr[++ tr] = rt[i];
    return query(1,len,k);
}
```

```c++
//树上主席树
int ask(int u,int v,int lca,int k)
{
    int r1 = rt[u],r2 = rt[v],l1 = rt[anc[lca][0]],l2 = rt[lca];
    int L = 1,R = len;
    while(L < R)
    {
        int mid = L + R >> 1;
        int d = tree[tree[r1].l].cnt + tree[tree[r2].l].cnt - tree[tree[l1].l].cnt - tree[tree[l2].l].cnt;
        if(d >= k)
            R = mid,r1 = tree[r1].l,r2 = tree[r2].l,l1 = tree[l1].l,l2 = tree[l2].l;
        else
            k -= d,L = mid + 1,r1 = tree[r1].r,r2 = tree[r2].r,l1 = tree[l1].r,l2 = tree[l2].r;
    }
    return L;
}
```







### 字符串

#### kmp

```c++
void getnxt(char s[]) {
    nxt[0] = nxt[1] = 0;
    int l = strlen(s);
    for(int i = 1;i < l;i ++) {
        int j = nxt[i];
        while(j && s[i] != s[j]) j = nxt[j];
        nxt[i + 1] = s[i] == s[j] ? j + 1 : 0;
    }
}
int kmp(char s1[],char s2[]) {
    getnxt(s1);
    int ans = 0;
    int n = strlen(s1),m = strlen(s2);
    for(int i = 0,j = 0;i < m;i ++) {
        while(j && s1[j] != s2[i]) j = nxt[j];
        if(s1[j] == s2[i]) j ++;
        if(j == n) ans ++;
    }
    return ans;
}
```

#### AC自动机/trie图

```c++
void build_trieg() {
	fail[0] = 0;
	for(int i = 1;i <= 26;i ++) {
		int u = ch[0][i];
		if(u) { q.push(u); fail[u] = 0; }
	}
	while(q.size()) {
		int f = q.front(); q.pop();
		val[f] += val[fail[f]];
		for(int c = 1;c <= 26;c ++) {
			int u = ch[f][c];
			if(!u) { ch[f][c] = ch[fail[f]][c]; continue; }
			q.push(u);
			fail[u] = ch[fail[f]][c];
		}
	}
}
void build_ac() {
    fail[0] = 0;
    for(int i = 0;i < 26;i ++) {
        int u = ch[0][i];
        if(u) { q.push(u); fail[u] = 0; }
    }
    while(q.size()) {
        int f = q.front(); q.pop();
        for(int i = 0;i < 26;i ++) {
            int u = ch[f][i];
            if(!u) continue;
            q.push(u);
            int v = fail[f];
            while(v && !ch[v][i]) v = fail[v];
            fail[u] = ch[v][i];
        }
    }
}
```

#### 后缀数组

```c++
struct SuffixArray {
    /// 串从0开始,a[len]是非法字符
    /// sa[i]表示排名为i的后缀 i在[0,len-1]
    /// lcp[i]表示sa[i]和sa[i-1]的lcp i在[1,len-1]
    int lcp[SZ],sa[SZ],rk[SZ],len;
    bool cmp(int *y,int a,int b,int k) {
        int a1 = y[a],b1 = y[b];
        int a2 = a + k >= len ? -1 : y[a + k];
        int b2 = b + k >= len ? -1 : y[b + k];
        return a1 == b1 && a2 == b2;
    }

    int t1[SZ],t2[SZ],cc[SZ];

    void get_sa(char s[],int m) {
        int *x = t1,*y = t2; /// 字符集
        for(int i = 0;i < m;i ++) cc[i] = 0;
        for(int i = 0;i < len;i ++) ++ cc[x[i] = s[i]];
        for(int i = 1;i < m;i ++) cc[i] += cc[i - 1];
        for(int i = len - 1;~i;i --) sa[-- cc[x[i]]] = i;
        for(int k = 1;k < len;k <<= 1) {
            int p = 0;
            for(int i = len - k;i < len;i ++)  y[p ++] = i;
            for(int i = 0;i < len;i ++) if(sa[i] >= k) y[p ++] = sa[i] - k;
            for(int i = 0;i < m;i ++) cc[i] = 0;
            for(int i = 0;i < len;i ++) ++ cc[x[y[i]]];
            for(int i = 1;i < m;i ++) cc[i] += cc[i - 1];
            for(int i = len - 1;~i;i --) sa[-- cc[x[y[i]]]] = y[i];
            swap(x,y); m = 1; x[sa[0]] = 0;

            for(int i = 1;i < len;i ++)
                x[sa[i]] = cmp(y,sa[i - 1],sa[i],k) ? m - 1 : m ++;
            if(m >= len) break;
        }
    }

    void get_lcp(char s[]) {
        for(int i = 0;i < len;i ++) rk[sa[i]] = i;
        int h = 0;
        lcp[0] = 0;
        for(int i = 0;i < len;i ++) {
            if(!rk[i]) continue;
            int j = sa[rk[i] - 1];
            if(h) h --;
            while(s[i + h] == s[j + h]) h ++;
            lcp[rk[i]] = h;
        }
    }

    void init(char *s,int n,int m) {
        len = n;
        get_sa(s,m); get_lcp(s);
    }
}sa;

template<size_t size>
struct SuffixArray {
    /// 串从0开始
    /// sa[i]表示排名为i的后缀 i在[1,len]
    /// rk[i]表示sa[i]和sa[i-1]的lcp i在[2,len]
    bool type[size << 1];
    int bucket[size], bucket1[size];
    int sa[size], rk[size], ht[size];
    inline bool isLMS(const int i, const bool *type) { return i > 0 && type[i] && !type[i - 1]; }
    template<class T>
    inline void inducedSort(T s, int *sa, const int len, const int sigma, const int bucketSize, bool *type, int *bucket, int *cntbuf, int *p) {
        memset(bucket, 0, sizeof(int) * sigma);
        memset(sa, -1, sizeof(int) * len);
        for (int i = 0; i < len; i++) bucket[s[i]]++;
        cntbuf[0] = bucket[0];
        for (int i = 1; i < sigma; i++) cntbuf[i] = cntbuf[i - 1] + bucket[i];
        for (int i = bucketSize - 1; i >= 0; i--) sa[--cntbuf[s[p[i]]]] = p[i];
        for (int i = 1; i < sigma; i++) cntbuf[i] = cntbuf[i - 1] + bucket[i - 1];
        for (int i = 0; i < len; i++) if (sa[i] > 0 && !type[sa[i] - 1]) sa[cntbuf[s[sa[i] - 1]]++] = sa[i] - 1;
        cntbuf[0] = bucket[0];
        for (int i = 1; i < sigma; i++) cntbuf[i] = cntbuf[i - 1] + bucket[i];
        for (int i = len - 1; i >= 0; i--) if (sa[i] > 0 && type[sa[i] - 1]) sa[--cntbuf[s[sa[i] - 1]]] = sa[i] - 1;
    }
    template<typename T>
    inline void sais(T s, int *sa, int len, bool *type, int *bucket, int *bucket1, int sigma) {
        int i, j, bucketSize = 0, cnt = 0, p = -1, x, *cntbuf = bucket + sigma;
        type[len - 1] = 1;
        for (i = len - 2; i >= 0; i--) type[i] = s[i] < s[i + 1] || (s[i] == s[i + 1] && type[i + 1]);
        for (i = 1; i < len; i++) if (type[i] && !type[i - 1]) bucket1[bucketSize++] = i;
        inducedSort(s, sa, len, sigma, bucketSize, type, bucket, cntbuf, bucket1);
        for (i = bucketSize = 0; i < len; i++) if (isLMS(sa[i], type)) sa[bucketSize++] = sa[i];
        for (i = bucketSize; i < len; i++) sa[i] = -1;
        for (i = 0; i < bucketSize; i++) {
            x = sa[i];
            for (j = 0; j < len; j++) {
                if (p == -1 || s[x + j] != s[p + j] || type[x + j] != type[p + j]) { cnt++, p = x; break; }
                else if (j > 0 && (isLMS(x + j, type) || isLMS(p + j, type))) break;
            }
            x = (~x & 1 ? x >> 1 : x - 1 >> 1), sa[bucketSize + x] = cnt - 1;
        }
        for (i = j = len - 1; i >= bucketSize; i--) if (sa[i] >= 0) sa[j--] = sa[i];
        int *s1 = sa + len - bucketSize, *bucket2 = bucket1 + bucketSize;
        if (cnt < bucketSize) sais(s1, sa, bucketSize, type + len, bucket, bucket1 + bucketSize, cnt);
        else for (i = 0; i < bucketSize; i++) sa[s1[i]] = i;
        for (i = 0; i < bucketSize; i++) bucket2[i] = bucket1[sa[i]];
        inducedSort(s, sa, len, sigma, bucketSize, type, bucket, cntbuf, bucket2);
    }
    template<class T>
    inline void getHeight(const T *s, const int len, const int *sa) {
        for (int i = 0, k = 0; i < len; i++) {
            if (rk[i] == 0) k = 0;
            else {
                if (k > 0) k--;
                int j = sa[rk[i] - 1];
                while (i + k < len && j + k < len && s[i + k] == s[j + k]) k++;
            }
            ht[rk[i]] = k;
        }
    }
    template<class T>
    inline void init(T s, int len, int sigma) {
        len ++; sigma ++;
        sais(s, sa, len, type, bucket, bucket1, sigma);
        for (int i = 1; i < len; i++) rk[sa[i]] = i;
        getHeight(s, len, sa);
    }
};
SuffixArray<SZ> sa;
```

#### z算法

```c++
void get_z(char s[]) { //z[i]:后缀i与原串的lcp长度
	int n = strlen(s + 1);
	int l = 1,r = 0;
	for(int i = 2;i <= n;i ++) {
		if(i >= l + r) {
			int h = 0;
			while(i + h <= n && s[i + h] == s[1 + h]) h ++;
			z[i] = h;
		}
		else {
			int k = i - l + 1;
			if(i + z[k] < l + r) z[i] = z[k];
			else {
				int h = l + r - i;
				while(i + h <= n && s[i + h] == s[1 + h]) h ++;
				z[i] = h;
			}
		}
		if(i + z[i] > l + r) l = i,r = z[i];
	}
}
```

#### SAM

```c++
node* insert(int x,node *lst,node *root) {
	node *p = lst,*np = newnode(p -> val + 1);
	while(p && !p -> ch[x]) p -> ch[x] = np,p = p -> par;
	if(!p) np -> par = root;
	else {
		node *q = p -> ch[x];
		if(q -> val == p -> val + 1) np -> par = q;
		else {
			node *nq = newnode(p -> val + 1);
			memcpy(nq -> ch,q -> ch,sizeof nq -> ch);
			nq -> par = q -> par;
			q -> par = nq; np -> par = nq;
			while(p && p -> ch[x] == q) p -> ch[x] = nq,p = p -> par;
		}
	}
	return np;
}
```

#### manacher

```c++
inline void prepare() {
    n = strlen(s1 + 1);
    s2[++len] = '@';
    s2[++len] = '#';
    for (int i = 1; i <= n; i++) {
        s2[++len] = s1[i];
        s2[++len] = '#';
    }
    s2[++len] = '\0';
}
inline void manacher() {
    int right = 0, pos = -1;
    for (int i = 1; i <= len; i++) {
        int x;
        if (right < i) x = 1;
        else x = std::min(r[2 * pos - i], right - i);
        while (s2[i - x] == s2[i + x]) x++;
        if (x + i > right) {
            right = x + i;
            pos = i;
        }
        r[i] = x;
    }
}
```

